
#define _XOPEN_SOURCE 500
#include <unistd.h> /* usleep */

#include "engine.h"
#include "board_print.h"

#include <stdio.h>
#include <assert.h>
#include <stdlib.h>

/* Tests are mostly generated by ChatGPT */

static void print_rook_test(const char *label,
                            enum square_index sq,
                            bitboard all_occ,
                            bitboard own_occ)
{
    printf("\n%s\n", label);
    printf("All occ:\n");
    bitboard_print(all_occ, stdout);
    printf("Own occ:\n");
    bitboard_print(own_occ, stdout);

    const bitboard attacks = rook_attacks_from_index(sq, all_occ) & ~own_occ;
    printf("Rook attacks:\n");
    bitboard_print(attacks, stdout);
}

static void test_rooks()
{
    {
        const enum square_index sq = SQ_INDEX_A1;
        const bitboard rook       = SQ_MASK_A1;
        const bitboard all_occ    = rook;
        const bitboard own_occ    = rook;

        /* Expected: full rank 1 and file A, except A1 */
        bitboard expected = (FILE_MASK_A | RANK_MASK_1) & ~SQ_MASK_A1;

        print_rook_test("Test 1: Rook at A1, empty board", sq, all_occ, own_occ);

        const bitboard attacks = rook_attacks_from_index(sq, all_occ) & ~own_occ;
        assert(attacks == expected);
    }

    {
        const enum square_index sq = SQ_INDEX_A1;
        const bitboard rook        = SQ_MASK_A1;
        const bitboard own_block   = SQ_MASK_A2 | SQ_MASK_B1;
        const bitboard all_occ     = rook | own_block;
        const bitboard own_occ     = all_occ;

        /* Expected: no legal moves (immediately blocked both directions) */
        const bitboard expected = 0ULL;

        print_rook_test("Test 2: Rook at A1, own blockers A2, B1", sq, all_occ, own_occ);

        const bitboard attacks = rook_attacks_from_index(sq, all_occ) & ~own_occ;
        assert(attacks == expected);
    }

    {
        const enum square_index sq = SQ_INDEX_A1;
        const bitboard rook        = SQ_MASK_A1;
        const bitboard enemies     = SQ_MASK_A3 | SQ_MASK_C1;
        const bitboard all_occ     = rook | enemies;
        const bitboard own_occ     = rook;

        /*
         * Expected:
         *  - Along file A: A2, A3 (enemy at A3 is capturable, stop there)
         *  - Along rank 1: B1, C1 (enemy at C1 capturable, stop there)
         */
        bitboard expected = 0ULL;
        expected |= SQ_MASK_A2 | SQ_MASK_A3;
        expected |= SQ_MASK_B1 | SQ_MASK_C1;

        print_rook_test("Test 3: Rook at A1, enemy blockers A3, C1", sq, all_occ, own_occ);

        const bitboard attacks = rook_attacks_from_index(sq, all_occ) & ~own_occ;
        assert(attacks == expected);
    }

        /* Rook Test 6: center rook on empty board */
    {
        const enum square_index sq = SQ_INDEX_E5;
        const bitboard rook        = SQ_MASK_E5;
        const bitboard all_occ     = rook;
        const bitboard own_occ     = rook;

        /* Full rank 5 and file E, except E5 itself */
        bitboard expected = (FILE_MASK_E | RANK_MASK_5) & ~SQ_MASK_E5;

        print_rook_test("Rook Test 6: E5, empty board", sq, all_occ, own_occ);

        bitboard attacks = rook_attacks_from_index(sq, all_occ) & ~own_occ;
        assert(attacks == expected);
    }

    /* Rook Test 7: center rook, mixed blockers on rays */
    {
        const enum square_index sq = SQ_INDEX_E5;
        const bitboard rook        = SQ_MASK_E5;

        /* Friendly: E7 and C5; Enemy: E3 and H5 */
        const bitboard friends     = rook | SQ_MASK_E7 | SQ_MASK_C5;
        const bitboard enemies     = SQ_MASK_E3 | SQ_MASK_H5;
        const bitboard all_occ     = friends | enemies;
        const bitboard own_occ     = friends;

        /*
         * From E5:
         *  Up:   E6, then friendly E7 (stop before E7)
         *  Down: E4, E3 (enemy, included, then stop)
         *  Left: D5, then friendly C5 (stop before C5)
         *  Right:F5, G5, H5 (enemy, included, then stop)
         */
        bitboard expected = 0ULL;
        expected |= SQ_MASK_E6;
        expected |= SQ_MASK_E4 | SQ_MASK_E3;
        expected |= SQ_MASK_D5;
        expected |= SQ_MASK_F5 | SQ_MASK_G5 | SQ_MASK_H5;

        print_rook_test("Rook Test 7: E5, friends E7/C5, enemies E3/H5", sq, all_occ, own_occ);

        bitboard attacks = rook_attacks_from_index(sq, all_occ) & ~own_occ;
        assert(attacks == expected);
    }

    /* Rook Test 8: edge rook on empty board (top edge, not corner) */
    {
        const enum square_index sq = SQ_INDEX_C8;
        const bitboard rook        = SQ_MASK_C8;
        const bitboard all_occ     = rook;
        const bitboard own_occ     = rook;

        /*
         * From C8:
         *  Down file C: C7..C1
         *  Across rank 8: A8,B8,D8,E8,F8,G8,H8
         */
        bitboard expected = 0ULL;
        expected |= (FILE_MASK_C & ~SQ_MASK_C8);
        expected |= (RANK_MASK_8 & ~SQ_MASK_C8);

        print_rook_test("Rook Test 8: C8, empty board", sq, all_occ, own_occ);

        bitboard attacks = rook_attacks_from_index(sq, all_occ) & ~own_occ;
        assert(attacks == expected);
    }

    /* Rook Test 9: rook completely boxed in by friendly orthogonal neighbors */
    {
        const enum square_index sq = SQ_INDEX_D4;
        const bitboard rook        = SQ_MASK_D4;
        const bitboard friends     = rook |
                                     SQ_MASK_D5 | SQ_MASK_D3 |
                                     SQ_MASK_C4 | SQ_MASK_E4;
        const bitboard enemies     = 0ULL;
        const bitboard all_occ     = friends | enemies;
        const bitboard own_occ     = friends;

        /* All four rays are immediately blocked by own pieces */
        const bitboard expected = 0ULL;

        print_rook_test("Rook Test 9: D4, boxed by own pieces at D5/D3/C4/E4",
                        sq, all_occ, own_occ);

        bitboard attacks = rook_attacks_from_index(sq, all_occ) & ~own_occ;
        assert(attacks == expected);
    }

    /* Rook Test 10: rook on file with non-interfering off-ray pieces */
    {
        const enum square_index sq = SQ_INDEX_A4;
        const bitboard rook        = SQ_MASK_A4;

        /* Pieces placed off the rook's rank/file; they should have no effect */
        const bitboard off_ray     = SQ_MASK_C1 | SQ_MASK_F6 | SQ_MASK_H8;
        (void)off_ray;
        const bitboard friends     = rook | SQ_MASK_C1;
        const bitboard enemies     = SQ_MASK_F6 | SQ_MASK_H8;
        const bitboard all_occ     = friends | enemies;
        const bitboard own_occ     = friends;

        /*
         * From A4:
         *  File A: A1..A8 except A4
         *  Rank 4: B4..H4
         * Pieces not on file A or rank 4 must not change attacks.
         */
        bitboard expected = 0ULL;
        expected |= (FILE_MASK_A | RANK_MASK_4) & ~SQ_MASK_A4;

        print_rook_test("Rook Test 10: A4, random off-ray pieces C1/F6/H8",
                        sq, all_occ, own_occ);

        bitboard attacks = rook_attacks_from_index(sq, all_occ) & ~own_occ;
        assert(attacks == expected);
    }
}


static void print_bishop_test(const char *label,
                              enum square_index sq,
                              bitboard all_occ,
                              bitboard own_occ)
{
    fprintf(stderr, "\n%s\n", label);
    fprintf(stderr, "All occ:\n");
    bitboard_print(all_occ, stderr);
    fprintf(stderr, "Own occ:\n");
    bitboard_print(own_occ, stderr);

    const bitboard attacks = bishop_attacks_from_index(sq, all_occ) & ~own_occ;
    fprintf(stderr, "Bishop attacks:\n");
    bitboard_print(attacks, stderr);
}

static void test_bishops(void)
{
    /* Test 1: Bishop at D4 on empty board (only bishop present) */
    {
        const enum square_index sq = SQ_INDEX_D4;
        const bitboard bishop      = SQ_MASK_D4;
        const bitboard all_occ     = bishop;
        const bitboard own_occ     = bishop;

        /*
         * Expected diagonals from D4:
         *  NE: E5, F6, G7, H8
         *  NW: C5, B6, A7
         *  SE: E3, F2, G1
         *  SW: C3, B2, A1
         */
        bitboard expected = 0ULL;
        expected |= SQ_MASK_E5 | SQ_MASK_F6 | SQ_MASK_G7 | SQ_MASK_H8;
        expected |= SQ_MASK_C5 | SQ_MASK_B6 | SQ_MASK_A7;
        expected |= SQ_MASK_E3 | SQ_MASK_F2 | SQ_MASK_G1;
        expected |= SQ_MASK_C3 | SQ_MASK_B2 | SQ_MASK_A1;

        print_bishop_test("Bishop Test 1: D4, empty board", sq, all_occ, own_occ);

        const bitboard attacks = bishop_attacks_from_index(sq, all_occ) & ~own_occ;
        assert(attacks == expected);
    }

    /* Test 2: Bishop at C1 on empty board (only bishop present) */
    {
        const enum square_index sq = SQ_INDEX_C1;
        const bitboard bishop      = SQ_MASK_C1;
        const bitboard all_occ     = bishop;
        const bitboard own_occ     = bishop;

        /*
         * From C1, diagonals:
         *  NE: D2, E3, F4, G5, H6
         *  NW: B2, A3
         *  SE / SW: none (edge of board)
         */
        bitboard expected = 0ULL;
        expected |= SQ_MASK_D2 | SQ_MASK_E3 | SQ_MASK_F4 |
                    SQ_MASK_G5 | SQ_MASK_H6;
        expected |= SQ_MASK_B2 | SQ_MASK_A3;

        print_bishop_test("Bishop Test 2: C1, empty board", sq, all_occ, own_occ);

        const bitboard attacks = bishop_attacks_from_index(sq, all_occ) & ~own_occ;
        assert(attacks == expected);
    }

    /* Test 3: Bishop at D4, friendly blockers at F6 and B2 (no enemies) */
    {
        const enum square_index sq = SQ_INDEX_D4;
        const bitboard bishop      = SQ_MASK_D4;
        const bitboard friends     = bishop | SQ_MASK_F6 | SQ_MASK_B2;
        const bitboard enemies     = 0ULL;
        const bitboard all_occ     = friends | enemies;
        const bitboard own_occ     = friends;

        /*
         * From D4:
         *  NE: E5, then blocked by friendly F6 (F6 not included)
         *  SW: C3, then blocked by friendly B2 (B2 not included)
         *  NW: C5, B6, A7 (no blockers)
         *  SE: E3, F2, G1 (no blockers)
         */
        bitboard expected = 0ULL;
        expected |= SQ_MASK_E5;
        expected |= SQ_MASK_C3;
        expected |= SQ_MASK_C5 | SQ_MASK_B6 | SQ_MASK_A7;
        expected |= SQ_MASK_E3 | SQ_MASK_F2 | SQ_MASK_G1;

        print_bishop_test("Bishop Test 3: D4, friendly blockers F6, B2", sq, all_occ, own_occ);

        const bitboard attacks = bishop_attacks_from_index(sq, all_occ) & ~own_occ;
        assert(attacks == expected);
    }

    /* Test 4: Bishop at D4, enemy blockers at F6 and B2 (no other friends) */
    {
        const enum square_index sq = SQ_INDEX_D4;
        const bitboard bishop      = SQ_MASK_D4;
        const bitboard friends     = bishop;
        const bitboard enemies     = SQ_MASK_F6 | SQ_MASK_B2;
        const bitboard all_occ     = friends | enemies;
        const bitboard own_occ     = friends;

        /*
         * From D4:
         *  NE: E5, F6 (enemy, included, then stop)
         *  SW: C3, B2 (enemy, included, then stop)
         *  NW: C5, B6, A7
         *  SE: E3, F2, G1
         */
        bitboard expected = 0ULL;
        expected |= SQ_MASK_E5 | SQ_MASK_F6;
        expected |= SQ_MASK_C3 | SQ_MASK_B2;
        expected |= SQ_MASK_C5 | SQ_MASK_B6 | SQ_MASK_A7;
        expected |= SQ_MASK_E3 | SQ_MASK_F2 | SQ_MASK_G1;

        print_bishop_test("Bishop Test 4: D4, enemy blockers F6, B2", sq, all_occ, own_occ);

        const bitboard attacks = bishop_attacks_from_index(sq, all_occ) & ~own_occ;
        assert(attacks == expected);
    }

    /* Test 5: Bishop at D4, mixed friend/enemy + another friendly bishop elsewhere */
    {
        const enum square_index sq = SQ_INDEX_D4;
        const bitboard bishop1     = SQ_MASK_D4;  /* tested bishop */
        const bitboard bishop2     = SQ_MASK_F4;  /* another friendly bishop */
        const bitboard friends     = bishop1 | bishop2 | SQ_MASK_F6;
        const bitboard enemies     = SQ_MASK_B2;
        const bitboard all_occ     = friends | enemies;
        const bitboard own_occ     = friends;

        /*
         * From D4:
         *  NE: E5, then friendly F6 (stop; F6 not included)
         *  SW: C3, B2 (enemy, included, then stop)
         *  NW: C5, B6, A7
         *  SE: E3, F2, G1
         *  Bishop at F4 is irrelevant; it does not sit on a diagonal from D4.
         */
        bitboard expected = 0ULL;
        expected |= SQ_MASK_E5;
        expected |= SQ_MASK_C3 | SQ_MASK_B2;
        expected |= SQ_MASK_C5 | SQ_MASK_B6 | SQ_MASK_A7;
        expected |= SQ_MASK_E3 | SQ_MASK_F2 | SQ_MASK_G1;

        print_bishop_test("Bishop Test 5: D4, mixed friend/enemy + extra bishop F4", sq, all_occ, own_occ);

        const bitboard attacks = bishop_attacks_from_index(sq, all_occ) & ~own_occ;
        assert(attacks == expected);
    }

    /* Test 6: Bishop at H8, no occupancy */
    {
        const enum square_index sq = SQ_INDEX_H8;
        const bitboard enemies     = 0ULL;
        const bitboard all_occ     = 0ULL;
        const bitboard own_occ     = SQ_MASK_FROM_INDEX(sq);

        /*
         * From D4:
         *  NE: E5, then friendly F6 (stop; F6 not included)
         *  SW: C3, B2 (enemy, included, then stop)
         *  NW: C5, B6, A7
         *  SE: E3, F2, G1
         *  Bishop at F4 is irrelevant; it does not sit on a diagonal from D4.
         */
        bitboard expected = 0ULL;
		expected = SQ_MASK_G7 | SQ_MASK_F6 | SQ_MASK_E5 | SQ_MASK_D4 |
			SQ_MASK_C3 | SQ_MASK_B2 | SQ_MASK_A1;

        print_bishop_test("Bishop Test 6: H8, no occupancy", sq, all_occ, own_occ);

        const bitboard attacks = bishop_attacks_from_index(sq, all_occ) & ~own_occ;
		if (attacks != expected) {
			bitboard_print(attacks, stderr);
		}
        assert(attacks == expected);
    }

    printf("\nAll bishop_attacks_from_index tests passed.\n");
}

int main()
{

    printf("sizeof pos:     %zu\n", sizeof (struct pos));
    printf("sizeof tt:      %zu\n", sizeof (struct tt));

#if 1
    test_rooks();
    test_bishops();
#endif

    for (int i = 40; i < 47; i++) {
        fprintf(stdout, "\033[30;%dm ", i);
    }
    fprintf(stdout, "\033[0m\n"); /* reset background color */

	/* board is too big for the stack */
	struct board* b = malloc(sizeof *b);
	if (!b) {
		abort();
	}
	*b = BOARD_INIT;

    //board_load_fen_unsafe(&board, "1n1q1rk1/r1p2P2/1p1pp2p/pB2P3/2P5/PPN5/6b1/3QK1NR b - - 0 1");
    //board_load_fen_unsafe(&board, "5R2/7k/P7/6pp/3B4/1PPK2bP/4r3/8 b - - 3 57");
    board_print_fen(&b->pos, stdout);
    board_print(&b->pos, NULL, stdout);

    struct move moves[MOVE_MAX];

    for (int turn = 0; turn < 200; ++turn) {
        size_t move_count = 0;
        all_moves(&b->pos, b->pos.player, &move_count, moves);

        if (move_count == 0) {
            printf("no moves for %s, aborting\n", player_str[b->pos.player]);
            board_print_threats(&b->pos, stdout, NULL);
            b->pos.player = opposite_player(b->pos.player);
            board_print_threats(&b->pos, stdout, NULL);
            break;
        }

        //struct move move = moves[0];
        struct search_result sr = search(b, b->pos.player, 7);

		struct move move = sr.move;
		double const score = sr.score;

        printf("move %d: {\n"
               "    .from = %s, (%s)\n"
               "    .to = %s,\n"
               "    .score = %lf,\n"
               "    .mask = ",
               turn,
               square_index_display[move.from],
               piece_str[b->mailbox[move.from]],
               square_index_display[move.to],
			   score
               );
        if (move.attr & MATTR_CAPTURE) printf("MATTR_CAPTURE ");
        if (move.attr & MATTR_PROMOTE) printf("MATTR_PROMOTE ");
        printf("\n}\n");

        enum move_result const r = board_move_2(b, move);

#if 1
        board_print_fen(&b->pos, stdout);
        tt_print_stats(&b->tt, stdout);
        board_print(&b->pos, &move, stdout);
#endif

        if (r == MR_STALEMATE) {
            printf("stalemate\n");
            break;
        }

        if (b->pos.pieces[PLAYER_WHITE][PIECE_KING] == 0ULL) {
            printf("white king gone!!\n");
            exit(1);
        }
        if (b->pos.pieces[PLAYER_BLACK][PIECE_KING] == 0ULL) {
            printf("black king gone!!\n");
            exit(1);
        }

        //usleep(1000000);
    }
    
    return EXIT_SUCCESS;
}

